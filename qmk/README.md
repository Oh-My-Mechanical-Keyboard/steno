# Firmware

## Overview

Shortly after I built the [first version](../pcb/README.md#Version-1) of the steno board, I got the idea of building a plug-and-playable steno keyboard. The idea was that I can compile the dictionary into a special format that's easier for the MCU to process, and load it on to a SD card. When I type on the keyboard, the MCU then doesn't send the strokes to the PC for Plover to process, but rather process the translation by itself, and send the actual key codes to the PC. Note that I originally planned to do this on a ATMega32u4, which runs on only 8MHz, 2.5kB of RAM, and 28kB of available application program space (the other 4k devoted to bootloader). The currently implementation runs on the [32u4 Bluefruit feather](https://www.adafruit.com/product/2829) fine, with most of the Plover dictionary formats compatible (including all the commands that don't include retro- functions). Currently, only text input is possible, and one would need to load a new dictionary from a PC in order to change the dictionary.

## Implementation

This firmware uses the [QMK firmware](https://qmk.fm), but strips off any useless features for a fully steno board, like layers. It uses the steno driver, but intercepts all the strokes by using `send_steno_chord_user`. Instead of sending them off to the host, the firmware performs several look ups in the dictionary, parses the entry, and outputs the needed key strokes. Loading dictionaries is done by implementing a raw HID device and receiving packets from a PC using the compiler, and this is currently only available for AVR, and I'm still working on a way to load dictionaries on ARM using Mass Storage Class.

The dictionary format will be documented in more detail in the compiler documentation, but basically the format is designed so that the MCU don't have to do a lot of work in order to look up some entry. The dictionary is organized as a tree, with each edge being a single stroke, and a whole path being a series of strokes, possibly leading to a entry, which would be stored in the node if there's one. The reason why it's a tree is because it's much easier to store and handle fixed sized data, as one can store them in place, without any kinds of pointers and size markers. The size of a stroke in this case is fixed, as it's a 23 bit integer corresponding to the 23 different keys on the steno board. In the early prototyping stage, the children of a node is organized as an array of pairs of strokes and the node addresses, sorted by the input stroke, so that the array can be binary searched, and the compiled dictionary would be very compact. Currently, in order to have better overall performance and make room for supporting in place dictionary editing, the children are organized as a hash map. Hash maps require empty space to perform well, and although that may seem like wasted space, it can also be used to cheaply add or remove entries in the future.

 In order to support Plover commands but to reduce the complexity, those are implemented as attributes of a entry. They are simply flags in the compiled dictionary, and they are evaluated when the outputs are you evaluated, changing the output or changing the state of the system which will go on affecting the next output along with the next entry attributes.

When searching for a entry, the firmware has an internal array of nodes. Each time a user inputs a stroke, the firmware will look up the stroke in the children of those nodes and the root node. If any new nodes are found, those become the new search array. Out of these nodes, the one with the longest match with an entry will be used, and the output will be evaluated and sent to the host.
